var documenterSearchIndex = {"docs":
[{"location":"bistability/#Bistability-in-the-Polariton-Condensate","page":"Bistability","title":"Bistability in the Polariton Condensate","text":"","category":"section"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"This example demonstrates the bistability phenomenon in a polariton condensate. The mean field equations describing this system may possess two stable solutions for certain parameters. They can be reached by varying the pump intensity, inducing a hysteresis loop. Here, we show the theoretical bistability curve and compare it with the results from a numerical simulation.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"First we load the necessary packages:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"using GeneralizedGrossPitaevskii, CairoMakie","category":"page"},{"location":"bistability/#The-analytical-solution","page":"Bistability","title":"The analytical solution","text":"","category":"section"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"The mean field of the polariton condensate is described by a driven dissipative Gross-Pitaevskii equation of the form","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"i fracpartial psipartial t = F(x t) + left( - delta - i fracgamma2 - frachbar nabla^22m + g psi^2 right)psi","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"In the above, ψ represents the wave function of the polariton condensate, which is a complex-valued function of space and time, F(x, t) is an external pump, which is a monochromatic term detuned from the cavity resonance by a frequency δ, γ is the decay rate of the polaritons, ħ is the reduced Planck constant, m is the effective mass of the polaritons, and g is the strength of the nonlinear interaction.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Here we define the numerical values of some of the parameters","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"ħ = 0.654 # (meV*ps)\nm = 1 / 3\ng = 0.01\nδ = 0.3\nγ = 0.1;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"It can be shown that, in a steady and homogeneous state, the intensity I = |F|^2 necessary to support the fluid at a given density n is given by the following function:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"function bistability_curve(n, δ, g, γ)\n    n * (γ^2 / 4 + (g * n - δ)^2)\nend;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Here, this theoretical curve is displayed:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"ns_theo = LinRange(0, 41, 512)\nIs_theo = bistability_curve.(ns_theo, δ, g, γ)\n\nwith_theme(theme_latexfonts()) do\n    fig = Figure(fontsize=16)\n    ax = Axis(fig[1, 1]; xlabel=\"I\", ylabel=\"n\")\n    lines!(ax, Is_theo, ns_theo, color=:blue, linewidth=4, label=\"Theoretical\")\n    fig\nend","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"It can be seen that, for certain values of the parameters, the system exhibits bistability, with two stable solutions for the same pump intensity.","category":"page"},{"location":"bistability/#The-numerical-solution","page":"Bistability","title":"The numerical solution","text":"","category":"section"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Now, we wish to reproduce the bistability curve using a numerical simulation. This is achieved by slowly varying the pump intensity and observing the resulting steady-state densities. The first step is to specify the equations governing the system.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Here is the dispersion term, which models the Laplacian in Fourier space. As these are constants, we also include the detuning and decay terms.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"function dispersion(ks, param)\n    param.ħ * sum(abs2, ks) / 2param.m - param.δ - im * param.γ / 2\nend;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Next, we define the nonlinear term.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"nonlinearity(ψ, param) = param.g * abs2(ψ[1]);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Finally, we define the pump profile. Here, we define the time-dependent pump intensity, which is a parabola that has zeros at t=0 and t=2tmax, and a maximum Imax at t=tmax.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"function I(t, tmax, Imax)\n    val = -Imax * t * (t - tmax) * 4 / tmax^2\n    val < 0 ? zero(val) : val\nend;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"We also define the complete pump profile, which includes both the spatial and temporal components. The spatial profile is a Gaussian centered in the middle of the system.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"function pump(x, param, t)\n    exp(-sum(abs2, x .- param.L / 2) / param.width^2) * √I(t, param.tmax, param.Imax)\nend;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"We now choose the numerical values of the pump constants:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"tmax = 4000\nImax = maximum(Is_theo)\nwidth = 50;\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"We now define the spatial grid used in the simulation:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"L = 256\nlengths = (L,)\nN = 128","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"The initial condition is a vector of zeros, corresponding to an initially empty cavity.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"u0 = (zeros(ComplexF64, N),);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Now the time parameters are defined:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"dt = 0.1\ntspan = (0, tmax);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Also, we define the number of saves and the algorithm to use.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"nsaves = 512\nalg = StrangSplitting();\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Finally, we collect all the necessary parameters in a named tuple","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"param = (; tmax, Imax, width, δ, ħ, m, γ, g, L);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Now, we define the problem and obtain the solution:","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, pump, param)\nts, sol = solve(prob, alg, tspan; dt, nsaves, show_progress=false);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"In the following plot, we can see the evolution of the density over time.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"with_theme(theme_latexfonts()) do\n    xs = (0:N-1) * (L / N)\n    fig = Figure(fontsize=24)\n    ax = Axis(fig[1, 1]; xlabel=L\"x\", ylabel=L\"t\")\n    heatmap!(ax, xs, ts, abs2.(sol[1]); colormap=:viridis, colorrange=(0, 40))\n    fig\nend","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"As expected, the density slowly rises as we increase the pump intensity. When the tip of the lower branch is reached, the system jumps suddenly to the upper branch. A backwards behavior is observed when decreasing the pump intensity, where the system can jump back to the lower branch.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Finally, we can compare the simulation results with the theoretical predictions. We do this by plotting the density as a function of the pump intensity.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"The pump intensity is given by the function I(t, tmax, Imax) calculated at the saved time points.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Is = I.(ts, tmax, Imax);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"On the other hand, the density is obtained from the solution evaluated at the center of the cavity, which is where the pump attains its maximum value.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"ns = abs2.(sol[1][N ÷ 2, :]);\nnothing #hide","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"Now, we plot the results, comparing with the theory discussed earlier.","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"with_theme(theme_latexfonts()) do\n    fig = Figure(fontsize=24)\n    ax = Axis(fig[1, 1]; xlabel=\"I\", ylabel=\"n\")\n    lines!(Is, ns; label=\"Simulation\", color=:red, linewidth=5)\n    lines!(ax, Is_theo, ns_theo, color=:blue, linewidth=5, label=\"Theory\", linestyle=:dash)\n    axislegend(ax, position=:rb)\n    fig\nend","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"We can see that the simulation closely matches the theoretical predictions,","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"","category":"page"},{"location":"bistability/","page":"Bistability","title":"Bistability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/","page":"References","title":"References","text":"I. Carusotto and C. Ciuti. Quantum fluids of light. Rev. Mod. Phys. 85, 299–366 (2013).\n\n\n\nI. Carusotto and C. Ciuti. Spontaneous microcavity-polariton coherence across the parametric threshold: Quantum Monte Carlo studies. Phys. Rev. B 72, 125335 (2005).\n\n\n\n","category":"page"},{"location":"exciton_polariton/#Exciton-polariton-system","page":"Exciton Polariton","title":"Exciton-polariton system","text":"","category":"section"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"In this example, we describe the polariton system as a two-component system consisting of excitons and photons inside a cavity. This will teach us how to model and simulate the dynamics of systems with two or more coupled components. The equations we want to solve are the following:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"i fracpartialpartial t beginpmatrix psi_c  psi_x endpmatrix =\nbeginpmatrix -delta_c - i gamma_c - frachbar^2 nabla^22m  Omega_r \nOmega_r  -delta_x - i gamma_x + g psi_x^2 endpmatrix\nbeginpmatrix psi_c  psi_x endpmatrix\n+ beginpmatrix F_c(x t)  0 endpmatrix","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"In the above, ψ_c and ψ_x are the photonic and excitonic components of the polariton wavefunction, respectively, δ_c and δ_x are the detunings of the cavity and exciton modes, γ_c and γ_x are their decay rates, m is the effective mass of the photons in the cavity, Ω_r is the Rabi frequency describing the coupling between photons and excitons, F_c(x, t) is the coherent pump acting on the photonic component, and g is the strength of the exciton-exciton nonlinear interactions.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"As always, we start by loading the package:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"using GeneralizedGrossPitaevskii","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"As we are modeling a two component system, there are some differences with respect to the single component case. The main one is that, as the wavefunction now has two components, the terms in the equation (dispersion, nonlinearity, and pump) must be defined as arrays. This has to be done using the StaticArrays.jl package, which allows us to define small fixed-size arrays efficiently, and, most importantly, allows us to use them in GPU kernels. For more information on why we use Static Arrays, see the Multicomponent Systems section of the documentation.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"The StaticArrays.jl package is reexported by GeneralizedGrossPitaevskii.jl, so we can use it directly. It's use is straightforward, usually only requiring the inclusion of the @SVector or @SMatrix macro in front of the array definition.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"With that in mind, here is the dispersion term:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"function dispersion(k, param)\n    Dcc = param.ħ * sum(abs2, k) / 2param.m - param.δc - im * param.γc\n    Dxx = -param.δx - im * param.γx\n    Dxc = param.Ωr\n    @SMatrix [Dcc Dxc; Dxc Dxx]\nend;\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"We include the detuning and decay terms in the dispersion, as they are constants, as well as the coupling term Ω_r and the Laplacian in Fourier space.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"In general, the nonlinear term is also a matrix, but in this case, it is diagonal. Therefore, it is sufficient and more efficient to define only the diagonal elements as a vector.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"nonlinearity(ψ, param) = @SVector [0, param.g * abs2(ψ[2])];\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"Finally, we define the pump profile, which is only applied to the photonic component. We choose a Gaussian profile in space, but any other profile could be used.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"function pump(r, param, t)\n    cpump = param.A * exp(-sum(abs2, r .- param.L / 2) / param.w^2)\n    xpump = zero(cpump)\n    @SVector [cpump, xpump]\nend;\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"Now, we define the parameters of the system and collect them in a named tuple. Notice that, to specify a system with two spatial dimensions, we only need to make the lengths tuple have two elements, one for each dimension, and the initial condition must be a tuple of two 2D arrays, one for each component. The initial condition we choose here corresponds to an empty cavity.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"ħ = 0.654 # (meV*ps)\nΩr = 4\nγx = 0.02\nγc = 0.16\nm = 1\n\nδx = -2.56\nδc = 0\n\nA = 2\nw = 100\n\ng = 0.015\n\nL = 256\nN = 128\nlengths = (L, L)\n\nparam = (; ħ, m, δc, γc, δx, γx, Ωr, A, w, g, L)\nu0 = (zeros(ComplexF64, N, N), zeros(ComplexF64, N, N));\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"Now, we define the problem, the number of saves, the time step, the time span, and the algorithm to use. We then are ready to solve it.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, pump, param)\nnsaves = 64\ndt = 5e-2\ntspan = (0, 100)\nalg = StrangSplitting()\nts, sol = solve(prob, alg, tspan; nsaves, dt, show_progress=false);\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"The solution sol is a tuple of two arrays, one for each component. Each array has dimensions (N, N, nsaves), where the first two dimensions correspond to space and the last one to time.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"To test our implementation, we can check that the steady-state solution obtained from the simulation matches the one obtained from the analytical expression. For a homogeneous pump, the steady-state solution can be shown to obey the following relations:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"left frac(delta_x + i gamma_x - g n_x)(delta_c + i gamma_c)Omega_r - Omega_r right^2 n_x = F_c^2 \nfracdelta_x + i gamma_x - g n_x^2Omega_r^2n_x = n_c","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"Although our pump is not homogeneous, it is approximately so in the center of the system, where the pump amplitude is close to A. Therefore, we can check the above relations using the densities at the center of the system at the final time.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"nx = abs2.(last(sol))[N÷2, N÷2, end]\nnc = abs2.(first(sol))[N÷2, N÷2, end];\nnothing #hide","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"We can check that the relations are satisfied approximately.","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"This is the first relation:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"abs2(Ωr - (δx + im * γx - g * nx) * (δc + im * γc) / Ωr) * nx / abs2(A) # ≈ 1","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"This is the second relation:","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"abs2(δx + im * γx - g * nx) * nx / Ωr^2 / nc # ≈ 1","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"","category":"page"},{"location":"exciton_polariton/","page":"Exciton Polariton","title":"Exciton Polariton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"stochastic_simulations/#Stochastic-Simulations","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Stochastic terms in the generalized Gross-Pitaevskii equation enable the simulation of quantum fluctuations and thermal effects through phase-space methods. GeneralizedGrossPitaevskii.jl supports noise terms in both position and momentum space, allowing for techniques such as the truncated Wigner approximation and Positive-P representation.","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"This page explains how to implement and configure stochastic terms for simulations.","category":"page"},{"location":"stochastic_simulations/#Noise-Implementation","page":"Stochastic Simulations","title":"Noise Implementation","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Stochastic terms are added to the deterministic Gross-Pitaevskii equation through noise amplitude functions that multiply Wiener processes. The general form is","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"i  du =   dt + eta(u mathbfr)  dW","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"To enable stochastic simulations, you must provide:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Noise amplitude function: position_noise_func\nNoise prototype: Template arrays defining noise structure and type\nModified problem constructor: Include noise terms in GrossPitaevskiiProblem","category":"page"},{"location":"stochastic_simulations/#Basic-Setup","page":"Stochastic Simulations","title":"Basic Setup","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Define noise prototype (same structure as initial condition)\nnoise_prototype = similar.(u0)\n\n# Position noise function\nposition_noise_func(u, r, param) = sqrt(param.γ / param.dx)\n\n# Create problem with noise\nprob = GrossPitaevskiiProblem(u0, lengths; \n    dispersion, nonlinearity, pump, param,\n    noise_prototype, position_noise_func)","category":"page"},{"location":"stochastic_simulations/#Ensemble-Simulations","page":"Stochastic Simulations","title":"Ensemble Simulations","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"For quantum phase-space methods, multiple stochastic trajectories are typically required. They can be implemented by adding an ensemble dimension to the initial condition:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Add ensemble dimension (e.g., 100 trajectories)\nu0_ensemble = (randn(ComplexF64, N, 100),)\n\n# Noise affects each trajectory independently\nprob = GrossPitaevskiiProblem(u0_ensemble, lengths; \n    dispersion, nonlinearity, pump, param,\n    noise_prototype, position_noise_func)","category":"page"},{"location":"stochastic_simulations/#Position-Space-Noise","page":"Stochastic Simulations","title":"Position Space Noise","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Position space noise is applied directly to the field in real space and is commonly used for:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Truncated Wigner method: Quantum vacuum fluctuations\nThermal noise: Temperature-dependent fluctuations  ","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Function signature:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"position_noise_func(u_tuple, r_tuple, param) → scalar or vector","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Common implementations:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Constant noise amplitude:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"position_noise_func(u, r, param) = sqrt(param.γ / param.dx)","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Field-dependent noise:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Noise proportional to local field amplitude (multiplicative noise)\nposition_noise_func(u, r, param) = param.α * abs(u[1])","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Spatially varying noise:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Noise with spatial profile (e.g., for pumped regions)\nposition_noise_func(u, r, param) = param.β * exp(-sum(abs2, r) / param.σ²)","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Multicomponent noise:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Different noise for each component\nfunction position_noise_func(u, r, param)\n    @SVector [sqrt(param.γ₁ / param.dx), sqrt(param.γ₂ / param.dx)]\nend","category":"page"},{"location":"stochastic_simulations/#Noise-Prototypes","page":"Stochastic Simulations","title":"Noise Prototypes","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"The noise_prototype parameter defines the structure, type, and size of the noise arrays used in stochastic integration. It must be a tuple with the same number of elements as the initial condition u0, and each element must have the same shape as the field components in u0, but may have a different type (e.g., real vs complex).","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Basic usage:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Single-component system\nu0 = (zeros(ComplexF64, N),)\nnoise_prototype = similar.(u0)\n\n# Multi-component system  \nu0 = (zeros(ComplexF64, N), zeros(ComplexF64, N))\nnoise_prototype = similar.(u0)","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Ensemble simulations:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Multiple stochastic trajectories (last dimension = ensemble)\nu0 = (zeros(ComplexF64, N, n_trajectories),)\nnoise_prototype = similar.(u0)\n\n# Each trajectory gets independent noise realizations","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Type considerations:","category":"page"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"# Complex noise \nnoise_prototype = (zeros(ComplexF64, N),)\n\n# Real noise\nnoise_prototype = (zeros(Float64, N),)\n\n# GPU arrays\nusing CUDA\nu0 = ((CUDA.zeros(ComplexF64, N)),)\nnoise_prototype = similar.(u0)  # Automatically CUDA arrays","category":"page"},{"location":"stochastic_simulations/#Important-Notes","page":"Stochastic Simulations","title":"Important Notes","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Memory allocation: The prototype determines memory layout and GPU/CPU placement\nEnsemble independence: Each trajectory in the ensemble dimension receives independent noise\nSize matching: Prototype must have the same spatial dimensions as field components","category":"page"},{"location":"stochastic_simulations/#Performance-Tips","page":"Stochastic Simulations","title":"Performance Tips","text":"","category":"section"},{"location":"stochastic_simulations/","page":"Stochastic Simulations","title":"Stochastic Simulations","text":"Use appropriate precision (Float32 vs Float64) for your hardware\nFor GPU simulations, ensure prototype arrays are GPU-resident","category":"page"},{"location":"quick_start/#Quick-Start","page":"Quick-Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"In this quick start example, we will demonstrate how to set up a simple Gross-Pitaevskii problem and solve it using the GeneralizedGrossPitaevskii package. As a first example, we will simulate free propagation of a wavefunction in a 2D grid. Later, we will add a nonlinear term in order to have a proper Gross-Pitaevskii equation.","category":"page"},{"location":"quick_start/#Free-Propagation","page":"Quick-Start","title":"Free Propagation","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We first load a few necessary packages.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"using GeneralizedGrossPitaevskii, CairoMakie, StructuredLight","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"CairoMakie and StructuredLight are used for visualization.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The first step is to define the parameters of the grid of our simulation. We will simulate a 2D system with a grid with N x N points with size of L x L.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"N = 128\nL = 8;\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now we define a lengths parameter:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"lengths = (L, L);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This is a tuple that defines the physical dimensions of the simulation domain. Each element corresponds to the size of the grid in each dimension. As we will be simulating a 2D system, and the grid is square, both elements are equal.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now, we turn to the definition of the initial condition of the wavefunction.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The first step is to define the inter-point distance in the grid:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"ΔL = L / N;\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This is used to create a range of points in the grid.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"rs = StepRangeLen(0, ΔL, N);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Observe that this package always assumes that the grid is of the form 0, ΔL, 2ΔL, ..., (N-1)ΔL. This is easily created with the StepRangeLen function.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We can use this grid to create an initial condition for the wavefunction:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"initial_condition = [exp(-(x - L / 2)^2 - (y - L / 2)^2) for x in rs, y in rs];\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This creates a 2D array representing a Gaussian wavefunction centered at the middle of the grid.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Let us visualize the initial condition:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"visualize(abs2.(initial_condition))","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"As this package is able to handle systems with multiple wavefunctions, we need to wrap the initial condition in a tuple with one element:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"u0 = (initial_condition,);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This indicates that we have one wavefunction in our simulation.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Next, we need to specify the equation that our system obeys. As this is a free propagation problem, the wavefunction satisfies the Schrödinger equation i ∂u(r, t)/∂t = -∇²u / 2. In Fourier space, this corresponds to a dispersion relation D(k) = |k|² / 2, which we now define:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"dispersion(ks, param) = sum(abs2, ks) / 2;\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The extra argument param is a placeholder for additional parameters, such as mass, that may be needed in more complex problems, but is not used here.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now we can create the problem instance:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This encapsulates all the necessary components to define the Gross-Pitaevskii equation.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now that we have defined the problem, we can solve it. We just need to specify some additional parameters: This is the algorithm we will use to solve the problem:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"alg = StrangSplitting();\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Right now, this is the only algorithm implemented in this package, so there isn't much choice.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This algorithm uses a fixed time step, which we can define:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"dt = 0.01;\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Next, we define the time span of the simulation:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"tspan = (0, 1);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This indicates that we want to simulate the system from time t=0 to t=1","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now, we indicate how many times we want to save the solution during the simulation:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"nsaves = 64;\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Finally, we can solve the problem:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"ts, sol = solve(prob, alg, tspan; nsaves, dt);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The solve function returns two values: the time points ts on which the solution was saved and the solution sol. sol is again a tuple, where each element corresponds to a wavefunction in the simulation. Each element in this tuple is an array with one extra dimension than the initial condition, which corresponds to the time dimension. We can use the save_animation function (which comes from StructuredLight and CairoMakie) to visualize the solution:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"save_animation(abs2.(sol[1]), \"free_prop_example.mp4\");\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"(Image: )","category":"page"},{"location":"quick_start/#Gross-Pitaevskii-Equation","page":"Quick-Start","title":"Gross-Pitaevskii Equation","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We will now add a nonlinear term to the equation, which will make it a proper Gross-Pitaevskii equation: i ∂u(r, t)/∂t = -∇²u / 2 + g|u|²u where g is a coupling constant that defines the strength of the nonlinearity.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"To add this nonlinear term, we need to define a new function that takes the wavefunction and returns the nonlinearity term (only the g|u|² part. Check GrossPitaevskiiProblem for more information.)","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"nonlinearity(u, param) = param.g * abs2(u[1]);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Here, we have used the param argument to pass the coupling constant g. We define this argument as a named tuple:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"param = (; g=-6);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The negative value of g indicates that we have an attractive nonlinearity, which will be clear in the visualization. Now we can create a new problem instance with the nonlinearity:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, param);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We used the same initial condition, lengths, and dispersion as before, but now we have added the nonlinearity and the parameters.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Just as before, we can solve the problem and visualize the solution:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"tspan = (0, 0.4)\nts, sol = solve(prob, alg, tspan; nsaves, dt, show_progress=false);\n\nsave_animation(abs2.(sol[1]), \"gross_pitaevskii.mp4\");\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The attractive nonlinearity will cause the wavefunction to collapse into a localized structure, which can be seen in the animation.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"(Image: )","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"algorithm_implementation/#Algorithm-Implementation","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"","category":"section"},{"location":"algorithm_implementation/#Rationale-for-Split-Step-Methods","page":"Algorithm Implementation","title":"Rationale for Split-Step Methods","text":"","category":"section"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"The generalized Gross-Pitaevskii equation contains terms that are naturally handled in different representations:","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"Dispersion term D(-inabla)u: Most efficiently computed in momentum space using FFTs\nPotential and nonlinearity terms V(mathbfr)u + G(u)u: Naturally computed in position space\nPump and noise terms: Applied in position space","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"A direct numerical solution would require expensive spatial derivatives for the dispersion term and complex implicit methods for the nonlinearity. Split-step methods solve this by:","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"Operator splitting: Decompose the evolution into separate steps, each handled in its optimal representation\nAnalytical solutions: Each substep can often be solved exactly (dispersion) or very efficiently (local terms)\nComputational efficiency: FFT-based dispersion steps are highly optimized and GPU-friendly\nFlexibility: Easy to add new terms without restructuring the entire algorithm","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"The Strang splitting scheme provides second-order accuracy by symmetrically arranging the substeps.","category":"page"},{"location":"algorithm_implementation/#Mathematical-Formulation","page":"Algorithm Implementation","title":"Mathematical Formulation","text":"","category":"section"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"The time evolution is implemented using a split-step method with Strang splitting. A single step of size dt from time t to t+dt is given by","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"    u = e^-iGdt2 e^-iVdt2(u + F(t)dt2) + F(t+dt2)dt2 -i sqrtdt2 eta dW \n    tildeu = e^-iDdttildeu  \n    u = e^-iGdt2 e^-iVdt2(u + F(t+dt2)dt2) + F(t+dt)dt2 -i sqrtdt2 eta dW ","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"In the above, u denotes the fields in real space, while ũ denotes the fields in Fourier space; G is the nonlinear term, V is the potential term, and D is the dispersion term. The term η is the noise amplitude, and dW is a Wiener increment, which is a normally distributed random variable with mean 0 and variance 1.","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"We can see that it is divided into three parts:","category":"page"},{"location":"algorithm_implementation/","page":"Algorithm Implementation","title":"Algorithm Implementation","text":"An evolution of u from time t to t+dt / 2 performed in real space, without the dispersion term.\nAn evolution of ũ from time t to t+dt, performed in Fourier space, without the nonlinear, potential and pump terms.\nAn evolution of u from time t+dt / 2 to t+dt, again performed in real space, without the dispersion term.","category":"page"},{"location":"api/#GeneralizedGrossPitaevskii.GrossPitaevskiiProblem","page":"API","title":"GeneralizedGrossPitaevskii.GrossPitaevskiiProblem","text":"GrossPitaevskiiProblem(u0, lengths; dispersion=additiveIdentity, potential=additiveIdentity,\n    nonlinearity=additiveIdentity, pump=additiveIdentity, position_noise_func=additiveIdentity, \n    momentum_noise_func=additiveIdentity, noise_prototype=additiveIdentity, param=nothing) -> GrossPitaevskiiProblem\n\nRepresents a generalized Gross-Pitaevskii equation problem with specified initial conditions and domain.\n\nThis struct encapsulates all components needed to define and solve a generalized Gross-Pitaevskii  equation, which describes the dynamics of quantum fluids such as Bose-Einstein condensates,  exciton-polariton condensates, and other nonlinear wave phenomena.\n\nThe equation to be solved is of the form:\n\ni du(r t) = D(-i)u + V(r)u + G(u)u + i F(r t)dt + η(u r) dW\n\nwhere:\n\nArguments\n\nu0::Tuple: Initial conditions for the fields. This should be a tuple of arrays, where each array  represents a field in the simulation. The fields should have the same shape.\nlengths::Tuple: Physical dimensions of the simulation domain.\ndispersion: D(-i∇) in the above equation. Should have  the signature dispersion(k, param), where k is a tuple representing a point in momentum space  and param are additional parameters.\npotential: V(r) in the above equation. Spatial potential function. Should have the signature  potential(r, param), where r is a tuple representing a point in direct space and param  are additional parameters.\nnonlinearity: G(u) in the above equation. Function defining nonlinear interaction terms. Should have  the signature nonlinearity(u, param), where u is a tuple representing the fields at a point  in direct space and param are additional parameters.\npump: F(r, t) in the above equation. Function defining pump/drive terms, may be time-dependent. Should have  the signature pump(r, param, t), where r is a tuple representing a point in direct space, param  are additional parameters, and t is time.\nposition_noise_func: η(u, r) in the above equation. Function defining stochastic terms in position. Should have the signature  noise_func(u, r, param), where u is a tuple representing the fields at a point in direct space r and  param are additional parameters.\nmomentum_noise_func: A counterpart of position_noise_func for momentum space. (Untested)\nnoise_prototype: ξ in the above equation. Prototype for noise terms. When specified, this should be a tuple  of arrays with the correct element type and shape for the noise terms. We will call randn!(rng, noise_prototype)  to generate the noise terms, which generates a random gaussian number with mean ⟨ξ⟩ = 0 and mean  absolute square ⟨|ξ|²⟩ = 1.\nparam: Additional parameters used by the component functions.\n\nExamples\n\n# Free propagation example\nL = 10\nN = 128\nu0 = (rand(ComplexF64, N, N),)\ndispersion(ks, param) = sum(abs2, ks) / 2\nprob = GrossPitaevskiiProblem(u0, (L, L); dispersion)\n\n# Exciton-polariton example\n\n# Define system parameters\nparam = (;\n\tħ = 1,           # Reduced Planck constant\n    m = 1,           # Effective mass\n    δc = 0,          # Cavity detuning\n    δx = 0,          # Exciton detuning\n    γc = 0.1,          # Cavity decay rate\n    γx = 0.1,          # Exciton decay rate\n    Ωr = 2,          # Rabi coupling\n    g = 0.01,          # Nonlinearity strength\n    A = 1,           # Pump amplitude\n    w = 2            # Pump width\n)\n\n# Define grid parameters\nL = 10\nN = 128\nlengths = (L, L)\n\n# Initial condition (photon and exciton fields)\nu0 = (zeros(ComplexF64, N, N), zeros(ComplexF64, N, N))\n\n# Define components of the generalized GP equation\nfunction dispersion(k, param)\n    Dcc = param.ħ * sum(abs2, k) / 2param.m - param.δc - im * param.γc\n    Dxx = -param.δx - im * param.γx\n    Dxc = param.Ωr\n    @SMatrix [Dcc Dxc; Dxc Dxx]\nend\n\nnonlinearity(u, param) = @SVector [0, param.g * abs2(u[2])]\n\nfunction pump(r, param, t)\n    @SVector [param.A * exp(-sum(abs2, r) / param.w^2), 0]\nend\n\n# Create the problem\nprob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, pump, param)\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonSolve.solve","page":"API","title":"CommonSolve.solve","text":"solve(prob, alg, tspan;\ndt,\nnsaves,\nshow_progress=true,\nprogress=nothing,\nsave_start=true,\nworkgroup_size=(),\nrng=nothing)\n\nThis function solves the given prob using the algorithm alg over the time span tspan.\n\nIt uses a fixed time step dt and saves the solution nsaves times during the simulation.\n\nThe show_progress argument controls whether a progress bar is shown, and progress can be used to provide a custom progress bar from ProgressMeter.jl.\n\nThe save_start argument indicates whether the initial condition should be saved.  If true, the initial condition is saved as the first entry in the result, and the size of the time dimension of the result is nsaves + save_start.\n\nThe workgroup_size argument can be used to specify the workgroup size for the kernel functions.\n\nThe rng argument can be used to provide a random number generator for the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeneralizedGrossPitaevskii.StrangSplitting","page":"API","title":"GeneralizedGrossPitaevskii.StrangSplitting","text":"StrangSplitting()\n\nThe Strang splitting algorithm for solving the Generalized Gross-Pitaevskii equation. It is a fixed time-stepping algorithm that alternates between diffusion and potential/pump/nonlinear steps.\n\n\n\n\n\n","category":"type"},{"location":"free_propagation_damping/#Damped-Free-Propagation","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"","category":"section"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"In this example, we will simulate a damped free propagation. We will define a simple 2D system with a Gaussian initial condition and a damping term in the dispersion relation to simulate the damping effect.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"We first load the necessary packages.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"using GeneralizedGrossPitaevskii, CairoMakie, StructuredLight","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"Then, we define the parameters of the grid for our simulation and the initial condition.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"L = 5\nlengths = (L, L)\ntspan = (0, 1)\nN = 128\nrs = StepRangeLen(0, L / N, N)\nu0 = (ComplexF64[exp(-(x - L / 2)^2 - (y - L / 2)^2) for x in rs, y in rs],);\nnothing #hide","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"Then, we define the dispersion relation with a damping term.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"dispersion(ks, param) = sum(abs2, ks) / 2 - im;\nnothing #hide","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"This corresponds to an equation of the form i ∂u(r, t)/∂t = -∇²u / 2 - i u, which includes a damping term due to the imaginary part.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"Now we can create the problem instance.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion);\nnothing #hide","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"Now, we define the solver parameters, get the solution and visualize the results.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"dt = 0.02\nnsaves = 64\nalg = StrangSplitting()\n\nts, sol = solve(prob, alg, tspan; dt, nsaves, show_progress=false);\n\nsave_animation(abs2.(sol[1]), \"free_prop_example_damp.mp4\", share_colorrange=true);\nnothing #hide","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"We can see that the wavefunction is damped over time, which is expected due to the damping term in the dispersion relation.","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"(Image: )","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"","category":"page"},{"location":"free_propagation_damping/","page":"Damped Free Propagation","title":"Damped Free Propagation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"general_overview/#General-Overview","page":"General Overview","title":"General Overview","text":"","category":"section"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"This page provides a comprehensive overview of the mathematical framework and user interface conventions of GeneralizedGrossPitaevskii.jl. Whether you're simulating Bose-Einstein condensates, exciton-polariton systems, or exploring quantum phase-space methods, understanding these fundamentals will help you effectively use the package for your research.","category":"page"},{"location":"general_overview/#The-Generalized-Gross-Pitaevskii-Equation","page":"General Overview","title":"The Generalized Gross-Pitaevskii Equation","text":"","category":"section"},{"location":"general_overview/#Mathematical-Form","page":"General Overview","title":"Mathematical Form","text":"","category":"section"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"The GeneralizedGrossPitaevskii.jl package solves equations of the form:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"i  du = left D(-inabla)u + V(mathbfr)u + G(u)u + i F(mathbfr t) right dt + eta(u mathbfr) dW","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"where:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"u(mathbfr t) is the complex (vector of) field(s)\nD(-inabla) represents the dispersion relation in momentum space\nV(mathbfr) is the external potential in position space\nG(u) captures nonlinear interactions depending on the field amplitude\nF(mathbfr t) represents time-dependent pumping or driving terms\neta is a noise amplitude function with Wiener increments dW","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"For multi-component systems, u becomes a vector of fields u = (u_1 u_2 ldots u_N), and the functions D, V, G can return matrices to describe coupling between components.","category":"page"},{"location":"general_overview/#Physical-Interpretation","page":"General Overview","title":"Physical Interpretation","text":"","category":"section"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Each term in the generalized equation represents a distinct physical mechanism:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Dispersion term D(-inabla)u: Governs the kinetic energy and momentum-dependent dynamics. For non-relativistic particles, this is typically D(k) = hbar k^2(2m), leading to the familiar -hbar^2nabla^2(2m) kinetic energy term.\nFunction signature: dispersion(k_tuple, param) → scalar, vector or matrix\nk_tuple: Tuple of momentum components (kₓ, kᵧ, ...)\nReturns: Scalar for single-component systems, matrix for multi-component coupling\nExample: dispersion(ks, p) = sum(abs2, ks) / (2 * p.mass)\nPotential term V(mathbfr)u: External fields, confinement potentials, or spatially varying energy landscapes that influence the dynamics.\nFunction signature: potential(r_tuple, param) → scalar, vector or matrix\nr_tuple: Tuple of position components (x, y, z, ...)\nReturns: Scalar for single-component systems, matrix for multi-component coupling\nExample: potential(rs, p) = 0.5 * p.ω² * sum(abs2, rs)\nNonlinearity term G(u)u: Captures interactions between particles or field components. Common examples include the cubic nonlinearity G(u) = gu^2 for contact interactions in Bose-Einstein condensates.\nFunction signature: nonlinearity(u_tuple, param) → scalar, vector or matrix\nu_tuple: Tuple of field components (u₁, u₂, ...)\nReturns: Scalar for single-component, vector for multi-component systems\nExample: nonlinearity(u, p) = p.g * abs2(u[1]) (single-component cubic)\nPump/Drive term F(mathbfr t): External pumping, driving, or dissipation.\nFunction signature: pump(r_tuple, param, t) → scalar or vector\nr_tuple: Tuple of position components (x, y, z, ...)\nparam: Parameter container\nt: Current time\nReturns: Scalar for single-component, vector for multi-component systems\nExample: pump(rs, p, t) = p.P₀ * exp(-sum(abs2, rs)/p.σ²) (Gaussian pump)\nStochastic terms eta dW: Quantum or thermal fluctuations. These enable quantum phase-space methods like the truncated Wigner approximation.\nFunction signatures:\nPosition noise: position_noise_func(u_tuple, r_tuple, param) → scalar, vector or matrix\nThe functions take field components and spatial coordinates, returning noise amplitudes\nExample: position_noise_func(u, rs, p) = sqrt(p.γ) (constant amplitude noise)","category":"page"},{"location":"general_overview/#Parameter-Management","page":"General Overview","title":"Parameter Management","text":"","category":"section"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Parameters are passed to all user-defined functions via the param argument. This provides a flexible way to pass physical constants, coupling strengths, and other system-specific values.","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Recommended approach:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Use named tuples for organized parameter storage: param = (; g=1.0, ω=2.0, γ=0.1)\nAccess parameters in functions: potential(rs, p) = 0.5 * p.ω^2 * sum(abs2, rs)\nParameters can be nothing if not needed: GrossPitaevskiiProblem(u0, lengths; dispersion)","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Multi-component systems:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Use @SMatrix and @SVector from StaticArrays for efficient small matrices and vectors\nExample coupling matrix: @SMatrix [g₁₁ g₁₂; g₁₂ g₂₂]","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"Identity functions:","category":"page"},{"location":"general_overview/","page":"General Overview","title":"General Overview","text":"additiveIdentity are used for zero terms (default for optional functions)\nThese avoid unnecessary computations when terms are not needed","category":"page"},{"location":"spatial_grid/#Spatial-Grid","page":"Spatial Grid","title":"Spatial Grid","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"GeneralizedGrossPitaevskii.jl uses uniform Cartesian grids with periodic boundary conditions implemented via Fast Fourier Transforms (FFTs). This page explains the grid conventions, coordinate systems, and how to set up spatial domains for your simulations.","category":"page"},{"location":"spatial_grid/#Grid-Conventions","page":"Spatial Grid","title":"Grid Conventions","text":"","category":"section"},{"location":"spatial_grid/#Physical-Domain-Setup","page":"Spatial Grid","title":"Physical Domain Setup","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"The spatial domain is defined by the lengths parameter, which is a tuple specifying the physical size in each spatial dimension:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"# 1D domain of size L\nlengths = (L,)\n\n# 2D domain of size Lₓ × Lᵧ  \nlengths = (Lₓ, Lᵧ)\n\n# 3D domain of size Lₓ × Lᵧ × Lz\nlengths = (Lₓ, Lᵧ, Lz)","category":"page"},{"location":"spatial_grid/#Grid-Points-and-Spacing","page":"Spatial Grid","title":"Grid Points and Spacing","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"For a domain of size L with N grid points, the package uses:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"Grid spacing: ΔL = L / N\nGrid points: 0, ΔL, 2ΔL, ..., (N-1)ΔL\nGrid creation: StepRangeLen(0, ΔL, N)","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"The grid always starts at zero and extends to L - ΔL, which is consistent with periodic boundary conditions where the point at L is equivalent to the point at 0.","category":"page"},{"location":"spatial_grid/#Position-Space-(Direct-Grid)","page":"Spatial Grid","title":"Position Space (Direct Grid)","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"For user convenience when setting up initial conditions or spatially varying functions, you can create position grids manually:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"N = 64\nL = 10.0\nΔL = L / N\nrs = StepRangeLen(0, ΔL, N)\n\n# Create initial condition\nu0 = [exp(-(x - L/2)^2) for x in rs]  # 1D Gaussian\nu0 = [exp(-(x - L/2)^2 - (y - L/2)^2) for x in rs, y in rs]  # 2D Gaussian","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"Internally, the package provides direct_grid(prob) which returns a tuple of ranges for each spatial dimension.","category":"page"},{"location":"spatial_grid/#Momentum-Space-(Reciprocal-Grid)","page":"Spatial Grid","title":"Momentum Space (Reciprocal Grid)","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"For dispersion relations, the package automatically generates momentum grids using FFT frequency conventions:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"1D momentum: k = fftfreq(N, 2π * N/L)\nAllowed momenta are discrete: k = 2πn/L where n is integer\nMomentum resolution: Δk = 2π/L\nRange: k ∈ [-π N/L, π N/L) with proper FFT ordering\nNyquist frequency (Maximum resolved momentum): kₘₐₓ = π N/L","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"The reciprocal grid is accessed internally reciprocal_grid(prob) and follows standard FFT conventions where negative frequencies come after positive ones.","category":"page"},{"location":"spatial_grid/#Boundary-Conditions","page":"Spatial Grid","title":"Boundary Conditions","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"GeneralizedGrossPitaevskii.jl exclusively uses periodic boundary conditions implemented through Fast Fourier Transforms. This choice provides several advantages:","category":"page"},{"location":"spatial_grid/#Why-Periodic-Boundaries?","page":"Spatial Grid","title":"Why Periodic Boundaries?","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"As FFTs naturally assume periodicity, we simply have to ask why to use FFTs at all. The main reasons are:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"FFT Efficiency: FFTs are computationally efficient for periodic problems, reducing the complexity from O(N²) to O(N log N). Furthermore, there are highly optimized libraries (like FFTW) that make FFTs very fast in practice, even with GPU acceleration (cuFFT).\nSimplicity: Easier to implement and maintain for arbitrary dimensionality compared to other boundary conditions","category":"page"},{"location":"spatial_grid/#Practical-Implications","page":"Spatial Grid","title":"Practical Implications","text":"","category":"section"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"Domain Size Considerations:","category":"page"},{"location":"spatial_grid/","page":"Spatial Grid","title":"Spatial Grid","text":"Choose domain size L large enough that the wavefunction is negligible at boundaries or consider using loss terms to dampen boundary effects\nFor localized states (e.g., solitons), ensure L ≫ characteristic_length_scale\nFor periodic structures, align domain size with the natural periodicity","category":"page"},{"location":"truncated_wigner/#Truncated-Wigner-method","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"In this example, we simulate the quantum properties of a coherently driven polariton fluid using the truncated Wigner method. In particular, we will compute the steady-state momentum distribution and the second-order correlation function in momentum space, g₂(k, k'). This will teach us how to include noise terms in our simulations, and how to extract quantum statistical properties from the results. We will see the appearance of strong correlations between modes with opposite momenta, which are a signature of pair production processes in the fluid.","category":"page"},{"location":"truncated_wigner/#Theoretical-Background","page":"Truncated Wigner method","title":"Theoretical Background","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The truncated Wigner method is a powerful technique for simulating the quantum dynamics of many-body systems. It approximates the quantum field by a classical stochastic field with appropriate initial conditions and noise terms. The stochastic differential equation we solve in this method takes the form:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"i dpsi = left( -delta - i fracgamma2 - frachbar nabla^22m + g (psi^2 - frac1textdx) right)psi dt + F dt + sqrtfracgamma2textdx dW(xt)","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Here, ψ is the polariton field, δ is the detuning, γ is the decay rate, m is the effective mass, g is the nonlinearity strength, F is the coherent pump, and dW(x,t) is a complex Wiener process.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"For more details on the derivation and validity of the truncated Wigner method, see [1, 2].","category":"page"},{"location":"truncated_wigner/#Simulation-of-the-steady-state","page":"Truncated Wigner method","title":"Simulation of the steady state","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"First, let's simulate the system without noise to establish the steady-state solution. This will serve as our reference point for understanding the quantum effects that appear when we add noise.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"using GeneralizedGrossPitaevskii, FFTW, CairoMakie, Statistics","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"We define the equation components according to our stochastic differential equation above. The dispersion relation includes the kinetic energy, detuning, and decay terms:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"function dispersion(ks, param)\n    param.ħ * sum(abs2, ks) / 2param.m - param.δ - im * param.γ / 2\nend;\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The pump is spatially uniform and constant in time:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"function pump(x, param, t)\n    param.A\nend;\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The nonlinearity includes a -1/dx regularization term:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"nonlinearity(ψ, param) = param.g * (abs2(first(ψ)) - 1 / param.dx);\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Now we define the physical parameters for a typical polariton system:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"ħ = 0.6582\nγ = 0.047 / ħ\nm = 1 / 6\ng = 3e-4 / ħ\nδ = 0.49 / ħ\nA = 10;\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Grid and parameters for a 1D system:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"L = 512\nN = 256\ndx = L / N\n\nlengths = (L,)\nparam = (; ħ, m, δ, γ, g, A, L, dx)","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"We initialize the field to zero and solve the mean-field Gross-Pitaevskii equation without noise:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"u0 = (zeros(ComplexF64, N),);\nprob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, pump, param)\nnsaves = 512\ndt = 0.05\ntspan = (0, 200)\nalg = StrangSplitting()\nts, sol = solve(prob, alg, tspan; nsaves, dt, show_progress=false);\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Let's examine how the density at one spatial point evolves toward steady state:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"ns = abs2.(sol[1][1, :])\n\nwith_theme(theme_latexfonts()) do\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel=\"t\", ylabel=\"n\")\n    lines!(ax, ts, ns; linewidth=2)\n    fig\nend","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"We can see the density approaches a steady-state value, confirming that our system reaches equilibrium.","category":"page"},{"location":"truncated_wigner/#Inclusion-of-quantum-noise","page":"Truncated Wigner method","title":"Inclusion of quantum noise","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Now we implement the full truncated Wigner method by including quantum noise. In this approach, we run many stochastic trajectories with random initial conditions and noise terms. Each trajectory represents one possible realization of the field evolution.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"We initialize with random Gaussian noise in the field amplitudes, as required by the Wigner representation of the vacuum state. We also define a second dimension that represents the ensemble of stochastic trajectories.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"u0 = (randn(ComplexF64, N, 256) / √(2dx),);\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The noise prototype specifies the shape and type of the noise to be added at each time step. In this case, it matches the shape and type of the initial condition.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"noise_prototype = similar.(u0);\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The position noise function corresponds to the √(γ/2dx) dW(x,t) term in our stochastic equation:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"position_noise_func(ψ, xs, param) = √(param.γ / (2param.dx));\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Now we solve the problem with noise included:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"prob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, pump, param, noise_prototype, position_noise_func)\nts, sol = solve(prob, alg, tspan; nsaves=1, dt, save_start=false, show_progress=false);\nnothing #hide","category":"page"},{"location":"truncated_wigner/#Extraction-of-quantum-statistical-properties","page":"Truncated Wigner method","title":"Extraction of quantum statistical properties","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"From the ensemble of stochastic trajectories, we can extract quantum statistical properties that are not accessible in classical mean-field simulations.","category":"page"},{"location":"truncated_wigner/#Occupation-number-in-momentum-space","page":"Truncated Wigner method","title":"Occupation number in momentum space","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"First, we transform to momentum space and calculate the average occupation number:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"ft_sol = fftshift(fft(sol[1], 1), 1) / N\nks = fftshift(fftfreq(N, 2π / dx));\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The momentum distribution n(k) is obtained by averaging |ψ(k)|² over all trajectories, with a correction term of -1/(2L) to account for the Wigner representation:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"nks = dropdims(mean(abs2, ft_sol; dims=2), dims=(2, 3)) .- 1 / (2L)\n\nwith_theme(theme_latexfonts()) do\n    fig = Figure(; fontsize=16)\n    ax2 = Axis(fig[1, 1]; xlabel=\"k\", ylabel=\"n(k)\")\n    ylims!(ax2, 0, 0.0025)\n    lines!(ax2, ks, nks, linewidth=2)\n    fig\nend","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The momentum distribution shows a symmetric peak at k=0 and tails extending to finite momentum. The result is noisy, but this is solved by simply increasing the number of stochastic trajectories.","category":"page"},{"location":"truncated_wigner/#Second-order-correlation-function-in-momentum-space","page":"Truncated Wigner method","title":"Second-order correlation function in momentum space","text":"","category":"section"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Now we calculate the second-order correlation function g₂(k,k'), which reveals quantum correlations between different momentum modes. This quantity is defined as:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"g_2(k k) = fraclangle hatpsi_1^*(k) hatpsi_2^*(k) hatpsi_1(k) hatpsi_2(k) ranglen(k) n(k)","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"where hatpsi denotes quantum field operators.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"In the Wigner representation, we must include corrections to account for the symmetrically ordered nature of the representation. Therefore, the calculation of g₂(k,k') from the stochastic fields requires the formula:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"langle hatpsi^dagger(k) hatpsi^dagger(k) hatpsi(k) hatpsi(k) rangle\n= leftlangle psi(k)^2 psi(k)^2 - frac12L(1 + delta_kk)\ncdot left( psi(k)^2 + psi(k)^2 - frac12L right) rightrangle_W","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"where ⟨...⟩_W denotes averaging over the stochastic trajectories in the Wigner representation.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"We define now some helper functions to compute this quantity correctly:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"function f(x, y, δ, commutator)\n    abs2(x) * abs2(y) - (1 + δ) * commutator / 2 * (abs2(x) + abs2(y) - commutator / 2)\nend\n\nfunction G2(sol, commutator)\n    result = similar(sol, real(eltype(sol)), (size(sol, 1), size(sol, 1)))\n\n    for n ∈ axes(result, 2), m in axes(result, 1)\n        result[m, n] = mapreduce((x, y) -> f(x, y, m == n, commutator), +,\n            view(sol, m, :), view(sol, n, :)) / size(sol, 2)\n    end\n\n    result\nend;\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Now we calculate the correlation function:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"G2k = G2(ft_sol, 1 / L)\ng2k = G2k ./ (nks * nks');\nnothing #hide","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"Visualize the correlation function:","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"with_theme(theme_latexfonts()) do\n    fig = Figure(; fontsize=16, size=(500, 400))\n    ax = Axis(fig[1, 1]; xlabel=L\"k\", ylabel=L\"k'\", aspect=DataAspect())\n    xlims!(ax, -0.6, 0.6)\n    ylims!(ax, -0.6, 0.6)\n    hm = heatmap!(ax, ks, ks, g2k, colorrange=(0, 3))\n    Colorbar(fig[1, 2], hm, label=L\"g_2(k, k')\")\n    fig\nend","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"The correlation function reveals strong correlations along the anti-diagonal (k ≈ -k'), which is a signature of spontaneous pair production processes in the driven-dissipative fluid. This quantum effect cannot be captured by classical mean-field theories and demonstrates the power of the truncated Wigner method for studying quantum many-body phenomena.","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"","category":"page"},{"location":"truncated_wigner/","page":"Truncated Wigner method","title":"Truncated Wigner method","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gpu/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"GeneralizedGrossPitaevskii.jl provides seamless GPU acceleration through KernelAbstractions.jl, enabling the same code to run efficiently on both CPU and GPU hardware. The package automatically detects array types and dispatches to appropriate compute backends, making GPU usage as simple as providing GPU arrays as initial conditions.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"This page explains how to enable GPU support, configure backends, and optimize performance for GPU simulations.","category":"page"},{"location":"gpu/#[KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl)","page":"GPU Support","title":"KernelAbstractions.jl","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"KernelAbstractions.jl provides a unified interface for writing GPU kernels that work across different backends (CUDA, ROCm, oneAPI, etc.). GeneralizedGrossPitaevskii.jl leverages this abstraction to provide hardware-agnostic simulations. Beyond CPU, the package has only been tested with the CUDA backend. The other backends are untested.","category":"page"},{"location":"gpu/#Specifying-the-GPU-backend","page":"GPU Support","title":"Specifying the GPU backend","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Different GPU backends require different array packages and setup procedures. The choice of backend depends on your hardware and software environment.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"For NVIDIA GPUs, use CUDA.jl, which needs to be installed separately:","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA, GeneralizedGrossPitaevskii\n\n# Check GPU availability\nCUDA.functional()  # Should return true\n\n# Create GPU arrays\nu0 = ((CUDA.zeros(ComplexF64, 512, 512)),)\n\n# Standard problem setup - automatically uses GPU\nprob = GrossPitaevskiiProblem(u0, lengths; dispersion, nonlinearity, param)\nts, sol = solve(prob, StrangSplitting(), tspan; dt, nsaves)","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"The other backends should work similarly, but have not been tested.","category":"page"},{"location":"gpu/#Performance-considerations","page":"GPU Support","title":"Performance considerations","text":"","category":"section"},{"location":"gpu/#Floating-Point-Precision","page":"GPU Support","title":"Floating Point Precision","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"GPU performance often benefits significantly from reduced precision, such as Float32 or ComplexF32, compared to Float64 or ComplexF64.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"# Double precision (slower, higher accuracy)\nu0_double = (CuArray(zeros(ComplexF64, N, N)),)\n\n# Single precision (faster, sufficient for most applications)\nu0_single = (CuArray(zeros(ComplexF32, N, N)),)","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Make sure to also change the types in the parameters and functions you provide (e.g., dispersion, nonlinearity) to match the precision of your arrays.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Consider the following factors when choosing precision:","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Accuracy requirements: Some applications may require higher precision\nMemory usage: Lower precision reduces memory consumption, allowing larger problems","category":"page"},{"location":"gpu/#Performance-Tips","page":"GPU Support","title":"Performance Tips","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Use appropriate precision: Float32 for most applications, Float64 only when necessary.\nChoose optimal grid sizes: Powers of 2 often perform better for FFTs\nEnsemble simulations: GPU parallelism is ideal for multiple stochastic trajectories. Be sure to use a large enough ensemble size to fully utilize the GPU.\nTune workgroup sizes: A workgroup_size parameter is available in the solve function to allow tuning of workgroup sizes for better performance.","category":"page"},{"location":"#GeneralizedGrossPitaevskii.jl","page":"Home","title":"GeneralizedGrossPitaevskii.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeneralizedGrossPitaevskii.jl is a Julia package for simulating a wide class of quantum fluid dynamics, from Bose-Einstein condensates to exciton-polariton systems, driven-dissipative fluids, and beyond.","category":"page"},{"location":"#Why-GeneralizedGrossPitaevskii.jl?","page":"Home","title":"Why GeneralizedGrossPitaevskii.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package unifies the simulation of diverse quantum fluid systems under a single, high-performance framework. With this package you can:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Focus on physics, not numerics: Describe complex systems with simple function definitions\nInclude quantum effects: Built-in support for phase space methods that allow the inclusion of quantum fluctuations through stochastic terms (e.g., Truncated Wigner approximation, Positive-P representation)\nHandle multi-component systems: Native support for coupled fields with elegant StaticArrays integration\nScale effortlessly: Same code runs efficiently on both CPU and GPU via KernelAbstractions.jl\nWork with one consistent interface: No need to learn different packages for different physical systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package solves a generalized Gross-Pitaevskii equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"i d u(r t) = D(-inabla)u + V(r)u + G(u)u + i F(r t)dt + eta(u r) dW","category":"page"},{"location":"","page":"Home","title":"Home","text":"This framework encompasses a vast range of quantum fluid phenomena, allowing researchers to concentrate on physics rather than numerical implementation details.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the Quick-Start guide to begin using the package, or explore the Examples (linked in the menu to the left) to see various physical systems in action. Their source files can be found in the examples/ directory of the GitHub repository.","category":"page"},{"location":"multicomponent_systems/#Multicomponent-Systems","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"","category":"section"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"Many quantum fluid systems involve multiple coupled fields, such as multi-component Bose-Einstein condensates or exciton-polariton systems. GeneralizedGrossPitaevskii.jl provides native support for these systems through efficient StaticArrays.jl integration, enabling both CPU and GPU simulations.","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"This page explains how to set up and work with multicomponent systems, from field initialization to operator definitions.","category":"page"},{"location":"multicomponent_systems/#Specifying-Multicomponent-Fields","page":"Multicomponent Systems","title":"Specifying Multicomponent Fields","text":"","category":"section"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"Multicomponent systems are defined by providing multiple field components as a tuple of arrays. Each component represents a different physical field.","category":"page"},{"location":"multicomponent_systems/#Field-Initialization","page":"Multicomponent Systems","title":"Field Initialization","text":"","category":"section"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"# Two-component system (e.g., exciton-polariton)\nN = 64\nL = 10.0\nΔL = L / N\nrs = StepRangeLen(0, ΔL, N)\n\n# Component 1: Photonic field (initially empty)\nψ_c = zeros(ComplexF64, N, N)\n\n# Component 2: Excitonic field (Gaussian profile)  \nψ_x = [exp(-(x - L/2)^2 - (y - L/2)^2) for x in rs, y in rs]\n\n# Multicomponent initial condition\nu0 = (ψ_c, ψ_x)","category":"page"},{"location":"multicomponent_systems/#Component-Organization","page":"Multicomponent Systems","title":"Component Organization","text":"","category":"section"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"Fields are ordered: The order in the tuple u0 = (ψ₁, ψ₂, ...) determines component indexing\nConsistent dimensions: All field components must have the same spatial dimensions\nType consistency: Components should have compatible element types (typically ComplexF64)","category":"page"},{"location":"multicomponent_systems/#Specifying-Multicomponent-Operators","page":"Multicomponent Systems","title":"Specifying Multicomponent Operators","text":"","category":"section"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"For multicomponent systems, some of the terms that define the equation (dispersion, potential, nonlinearity) are matrices, while the pump is a vector. ","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"As an example, the dispersion term for a two-component exciton-polariton system can be defined as:","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"function dispersion(k, param)\n    Dcc = param.ħ * sum(abs2, k) / 2param.m - param.δc - im * param.γc\n    Dxx = -param.δx - im * param.γx\n    Dxc = param.Ωr\n    @SMatrix [Dcc Dxc; Dxc Dxx]\nend","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"We see here that it is a 2x2 matrix, with the diagonal elements corresponding to the photonic and excitonic components, and the off-diagonal elements representing their coupling. One just needs to ensure the inclusion of the @SMatrix macro reexported from StaticArrays.jl in front of the usual matrix definition.","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"From the same example, the nonlinearity is diagonal, so it is sufficient to define only the diagonal elements as a vector:","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"nonlinearity(ψ, param) = @SVector [0, param.g * abs2(ψ[2])]","category":"page"},{"location":"multicomponent_systems/","page":"Multicomponent Systems","title":"Multicomponent Systems","text":"This is a general feature of multicomponent systems in GeneralizedGrossPitaevskii.jl: diagonal operators can be defined as vectors, while full operators must be defined as matrices. Furthermore, if the operator is a multiple of the identity matrix, it can be simply defined as a scalar.","category":"page"}]
}
